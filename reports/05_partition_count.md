# パーティション数の影響 比較レポート

## 概要

MySQL のパーティション上限は **8,192** 個。
パーティション数がパフォーマンスに与える影響を検証。

---

## テスト条件

- レコード数: **1,000,000件**
- パーティション種類: **HASH(id)** および **RANGE(id)**
- テストパターン: 8 / 100 / 1,000 / 8,000 パーティション

### 1パーティションあたりのレコード数

| パーティション数 | レコード数/パーティション |
|-----------------|-------------------------|
| 8 | 125,000 |
| 100 | 10,000 |
| 1,000 | 1,000 |
| 8,000 | 125 |

---

## 1. PK検索（単一行）

### クエリ
```sql
SELECT * FROM books_hash_{N} WHERE id = 500000;
```

### 結果

| パーティション数 | 初回 | キャッシュ後 |
|-----------------|------|-------------|
| なし | 835µs | 365µs |
| **8** | 945µs | **287µs** |
| 100 | 1.1ms | **244µs** |
| 1,000 | 2.3ms | **237µs** |
| **8,000** | **11.2ms** | **516µs** |

### EXPLAIN 分析

#### 8 パーティション
```sql
EXPLAIN SELECT * FROM books_hash_8 WHERE id = 500000;
```
```
type: const
partitions: p0
key: PRIMARY
rows: 1
```
**考察**: 単一パーティションのみアクセス。パーティション特定のオーバーヘッドは最小限。

#### 8000 パーティション
```sql
EXPLAIN SELECT * FROM books_hash_8000 WHERE id = 500000;
```
```
type: const
partitions: p4000
key: PRIMARY
rows: 1
```
**考察**: EXPLAIN 上は単一パーティションだが、**8000パーティションのメタデータ管理オーバーヘッド**が発生。初回アクセスで11.2msもかかる原因。

### 分析
- 8〜1000: キャッシュ後は高速
- **8000: 初回が非常に遅い（11.2ms）**
- キャッシュ後も他より2倍遅い

---

## 2. ID範囲検索（10,001行）

### クエリ
```sql
SELECT COUNT(*) FROM books_hash_{N} WHERE id BETWEEN 100000 AND 110000;
```

### 結果

| パーティション数 | 時間 | 比較 |
|-----------------|------|------|
| 100 | **9.9ms** | baseline |
| 1,000 | 25.3ms | 2.5倍遅い |
| **8,000** | **1.1秒** | **111倍遅い** |

### EXPLAIN 分析

#### 100 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_100 WHERE id BETWEEN 100000 AND 110000;
```
```
type: range
partitions: p0,p1,p2,...,p99
key: PRIMARY
rows: 10001
```
**考察**: 100パーティション全てをスキャン。各パーティションで少量のデータを検索。

#### 8000 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8000 WHERE id BETWEEN 100000 AND 110000;
```
```
type: range
partitions: p0,p1,p2,...,p7999
key: PRIMARY
rows: 10001
```
**考察**: **8000パーティション全てをスキャン**。パーティションごとのオープン/クローズのオーバーヘッドが累積し、111倍の遅延。

### 分析
- **8000パーティションは壊滅的に遅い**
- HASH パーティションでの範囲検索は全パーティションスキャン
- パーティション数が多いとスキャンコストが増大

---

## 3. 日付範囲検索（16,041行）

### クエリ
```sql
SELECT COUNT(*) FROM books_hash_{N}
WHERE created_at BETWEEN '2022-06-01' AND '2022-06-30';
```

### 結果

| パーティション数 | 時間 | 比較 |
|-----------------|------|------|
| なし | 8.3ms | baseline |
| **8** | **3.1ms** | **最速** |
| 100 | 15.5ms | 5倍遅い |
| 1,000 | 21.6ms | 7倍遅い |
| **8,000** | **944ms** | **304倍遅い** |

### EXPLAIN 分析

#### 8 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8
WHERE created_at BETWEEN '2022-06-01' AND '2022-06-30';
```
```
type: range
partitions: p0,p1,p2,p3,p4,p5,p6,p7
key: idx_created_at
rows: 16041
Extra: Using where; Using index
```
**考察**: 8パーティション全スキャンだが、オーバーヘッドが小さい。インデックスで効率的に絞り込み。

#### 8000 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8000
WHERE created_at BETWEEN '2022-06-01' AND '2022-06-30';
```
```
type: range
partitions: p0,p1,p2,...,p7999
key: idx_created_at
rows: 16041
```
**考察**: **8000パーティション全てを開いてインデックススキャン**。各パーティションに平均2行しかないが、オープン/クローズコストが304倍の遅延を引き起こす。

### 分析
- **8パーティションが最速**
- パーティション数が増えると急激に遅くなる
- 8000は実用不可

---

## 4. Full Table COUNT

### クエリ
```sql
SELECT COUNT(*) FROM books_hash_{N};
```

### 結果

| パーティション数 | 時間 | 比較 |
|-----------------|------|------|
| なし | 299ms | baseline |
| **8** | **85ms** | **最速** |
| 100 | 193ms | - |
| **1,000** | **67ms** | 最速級 |
| 8,000 | 193ms | - |

### EXPLAIN 分析

#### パーティションなし
```sql
EXPLAIN SELECT COUNT(*) FROM books;
```
```
type: index
key: PRIMARY
rows: 1000000
Extra: Using index
```
**考察**: 単一インデックスをシーケンシャルスキャン。

#### 8 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8;
```
```
type: index
partitions: p0,p1,p2,p3,p4,p5,p6,p7
key: PRIMARY
rows: 1000000
Extra: Using index
```
**考察**: 8パーティションを順次カウント。パーティション数が少ないためオーバーヘッド最小。

#### 8000 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8000;
```
```
type: index
partitions: p0,p1,p2,...,p7999
key: PRIMARY
rows: 1000000
Extra: Using index
```
**考察**: 8000パーティションを順次オープン/クローズ。各パーティションに125行しかないが、メタデータアクセスのオーバーヘッドが大きい。

### 分析
- 8 と 1000 が高速
- **意外な結果**: 1000パーティションが最速（67ms）の理由は不明。測定誤差の可能性もある
- **8000パーティション**: メタデータ管理のオーバーヘッドが大きく、8パーティションより遅い

---

## 5. テーブルサイズ

| パーティション数 | データサイズ | インデックスサイズ |
|-----------------|-------------|------------------|
| 8 | 0.13MB | 0.25MB |
| 100 | 1.56MB | 3.13MB |
| 1,000 | 15.63MB | 31.25MB |
| **8,000** | **125MB** | **250MB** |

### 分析
- パーティション数に比例してオーバーヘッド増大
- 8000パーティションでは375MBの追加オーバーヘッド

### なぜパーティション数でサイズが増えるのか？

| 要因 | 説明 |
|------|------|
| **メタデータ** | 各パーティションに .ibd ファイルとメタデータが必要 |
| **B-tree構造** | 各パーティションに独立したインデックスツリーが作成される |
| **ページの無駄** | 少量データでも最小ページサイズ（16KB）が割り当てられる |
| **内部フラグメント** | 小さなパーティションほどページ利用効率が低下 |

```
8パーティション: 1パーティション = 125,000行 → 効率的なページ利用
8000パーティション: 1パーティション = 125行 → 多くのページが空き状態
```

**計算例**:
- 8000パーティション × 最小16KBページ × 複数ページ ≈ 大量のオーバーヘッド

---

## 6. INSERT パフォーマンス

10,000,000件のINSERT時間（参考値）:

| パーティション数 | INSERT時間 |
|-----------------|-----------|
| 8 | 数分 |
| 100 | 数分 |
| 1,000 | 十数分 |
| **8,000** | **70分以上** |

### 分析
- 8000パーティションへのINSERTは極めて遅い
- バルクINSERTでも改善しない

### なぜ INSERT が遅いのか？

| フェーズ | 8パーティション | 8000パーティション |
|---------|---------------|-------------------|
| パーティション特定 | 高速（8分の1） | 低速（8000分の1の計算） |
| ファイルオープン | 8ファイル | 8000ファイル（OS制限に近い） |
| バッファプール | 効率的 | 頻繁なページイン/アウト |
| ロック競合 | 少ない | 多い（パーティションごとにロック） |

**バルクINSERTでも改善しない理由**:
```
1回のINSERTで複数行を挿入しても:
- 各行が異なるパーティションに分散
- パーティションごとにファイルアクセス
- 結果: シーケンシャルI/OがランダムI/Oになる
```

---

---

## RANGE パーティションでの検証

HASH と比較するため、同じパーティション数で RANGE(id) パーティションを検証。

### テーブル構成

```sql
PARTITION BY RANGE (id) (
    PARTITION p0 VALUES LESS THAN (125000),  -- 8パーティションの場合
    ...
);
```

| パーティション数 | ID範囲/パーティション |
|-----------------|---------------------|
| 8 | 125,000 |
| 100 | 10,000 |
| 1,000 | 1,000 |
| 8,000 | 125 |

---

### 7. RANGE: PK検索（単一行）

```sql
SELECT * FROM books_range_{N} WHERE id = 500000;
```

| パーティション数 | 初回 | キャッシュ後 |
|-----------------|------|-------------|
| **8** | **4.8ms** | **0.24ms** |
| 100 | 5.3ms | 0.69ms |
| 1,000 | 12.3ms | 0.27ms |
| **8,000** | **83.3ms** | 0.40ms |

**考察**: RANGE でも HASH 同様、8000パーティションの初回アクセスが極めて遅い（83ms）。ただしキャッシュ後は差が縮まる。

---

### 8. RANGE: ID範囲検索（パーティション内）

```sql
SELECT COUNT(*) FROM books_range_{N} WHERE id BETWEEN 100000 AND 110000;
```

| パーティション数 | 時間 | アクセスパーティション数 |
|-----------------|------|----------------------|
| **8** | **7.5ms** | 1 (p0) |
| 100 | 15.9ms | 2 (p10, p11) |
| 1,000 | 15.4ms | 11 (p100-p110) |
| 8,000 | 11.5ms | 81 (p800-p880) |

**考察**: RANGE の大きなメリットは**パーティションプルーニング**。8パーティションでは p0 のみアクセスで最速。HASH では全パーティションスキャンが必要だったが、RANGE では該当パーティションのみアクセス。

---

### 9. RANGE: ID範囲検索（パーティション跨ぎ）

```sql
SELECT COUNT(*) FROM books_range_{N} WHERE id BETWEEN 120000 AND 130000;
```

| パーティション数 | 時間 | アクセスパーティション数 |
|-----------------|------|----------------------|
| **8** | 14.5ms | 2 (p0, p1) |
| **100** | **14.3ms** | 2 (p12, p13) |
| 1,000 | 29.4ms | 11 |
| **8,000** | **50.8ms** | 81 |

**考察**: パーティション境界をまたぐ検索でも、RANGE はアクセス範囲が限定される。8000パーティションでも81パーティションのみアクセス（HASH の全8000パーティションスキャンと比較して大幅に高速）。

---

### 10. RANGE: 日付範囲検索（パーティションキー以外）

```sql
SELECT COUNT(*) FROM books_range_{N}
WHERE created_at BETWEEN '2022-06-01' AND '2022-06-30';
```

| パーティション数 | 時間 | 比較 |
|-----------------|------|------|
| **8** | **8.7ms** | baseline |
| 100 | 25.2ms | 2.9倍遅い |
| 1,000 | 40.2ms | 4.6倍遅い |
| **8,000** | **204.8ms** | **23.5倍遅い** |

**考察**: パーティションキー以外（created_at）での検索は全パーティションスキャン。HASH と同様の傾向だが、HASH(944ms) より RANGE(204.8ms) の方が高速。

---

### 11. RANGE: Full COUNT

```sql
SELECT COUNT(*) FROM books_range_{N};
```

| パーティション数 | 時間 |
|-----------------|------|
| 8 | 555.5ms |
| 100 | 636.8ms |
| 1,000 | 500.6ms |
| **8,000** | **127.5ms** |

**考察**: 意外にも8000パーティションが最速。理由は不明だが、RANGE パーティションでは各パーティションの COUNT が効率的に処理される可能性がある。

---

### 12. RANGE: author_id検索（セカンダリインデックス）

```sql
SELECT COUNT(*) FROM books_range_{N} WHERE author_id = 5000;
```

| パーティション数 | 時間 | 比較 |
|-----------------|------|------|
| **8** | **7.8ms** | baseline |
| 100 | 65.2ms | 8.4倍遅い |
| 1,000 | 480.9ms | 61.7倍遅い |
| **8,000** | **1,657.6ms** | **212倍遅い** |

**考察**: パーティションキー以外での検索は壊滅的。8000パーティションでは約1.7秒かかる。全パーティションのセカンダリインデックスを順次スキャンするため。

---

### 13. RANGE: テーブルサイズ

| パーティション数 | データ | インデックス | 合計 |
|-----------------|-------|------------|------|
| 8 | 0.13MB | 0.25MB | **0.38MB** |
| 100 | 1.56MB | 3.13MB | 4.69MB |
| 1,000 | 15.63MB | 31.25MB | 46.88MB |
| **8,000** | **125MB** | **250MB** | **375MB** |

**考察**: HASH と同じサイズ。パーティション数に比例してオーバーヘッドが増大。

---

### HASH vs RANGE 比較まとめ

| クエリ | HASH 8000 | RANGE 8000 | 勝者 |
|-------|-----------|------------|------|
| PK検索（初回） | 11.2ms | 83.3ms | HASH |
| ID範囲検索（パーティション内） | 1.1秒 | 11.5ms | **RANGE（96倍高速）** |
| 日付範囲検索 | 944ms | 204.8ms | **RANGE（4.6倍高速）** |
| Full COUNT | 193ms | 127.5ms | RANGE |
| author_id検索 | - | 1,657.6ms | 両方遅い |

**結論**:
- **RANGE は範囲検索で圧倒的に有利**（パーティションプルーニングが効く）
- **HASH は PK 検索で有利**（ハッシュ計算のみでパーティション特定）
- **8000パーティションはどちらも避けるべき**

---

## 推奨パーティション数

| ユースケース | 推奨数 | 理由 |
|-------------|-------|------|
| 一般的な用途 | **8〜16** | 本検証で最速 |
| 大量データ（100M+） | **要検証** | 本検証では未検証のため推奨値を示せない |
| 時系列データ | **年数分** | 年ごと分割（月ごとは過剰な可能性） |
| 絶対避けるべき | **1000以上** | オーバーヘッド大 |

---

## 結論

### 8000パーティションは実用不可
- **HASH**: 範囲検索 100〜300倍遅い
- **RANGE**: パーティションキー以外の検索 200倍遅い
- INSERT: **70分以上**（10M件）
- ストレージオーバーヘッド: **375MB**

### 最適なパーティション数は 8〜16
- PK検索: 変わらないか高速
- 範囲検索: 最も高速（RANGE でパーティションプルーニング効果大）
- INSERT: 許容範囲
- ストレージ: 最小限のオーバーヘッド

### HASH vs RANGE の選択
- **PK検索が多い** → HASH
- **範囲検索が多い** → RANGE（パーティションプルーニングが効く）
- **パーティションキー以外の検索が多い** → パーティション数を最小限に抑える

### パーティション数の目安

**本検証データに基づく推奨**:

| データ量 | 推奨パーティション数 | 根拠 |
|---------|-------------------|------|
| 1M件 | **8〜16** | 検証で8が最速 |
| 10M件 | **8〜16** | 大きく増やすメリットなし |
| 100M件以上 | **要追加検証** | 本検証では未検証 |

**注意**: 100パーティションでは既に日付範囲検索が5倍遅くなる結果が出ている。「パーティション数を増やすほど良い」という考えは誤り。
