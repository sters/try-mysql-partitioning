# パーティション数の影響 比較レポート

## 概要

MySQL のパーティション上限は **8,192** 個。
パーティション数がパフォーマンスに与える影響を検証。

---

## テスト条件

- レコード数: **1,000,000件**
- パーティション種類: HASH(id)
- テストパターン: 8 / 100 / 1,000 / 8,000 パーティション

### 1パーティションあたりのレコード数

| パーティション数 | レコード数/パーティション |
|-----------------|-------------------------|
| 8 | 125,000 |
| 100 | 10,000 |
| 1,000 | 1,000 |
| 8,000 | 125 |

---

## 1. PK検索（単一行）

### クエリ
```sql
SELECT * FROM books_hash_{N} WHERE id = 500000;
```

### 結果

| パーティション数 | 初回 | キャッシュ後 |
|-----------------|------|-------------|
| なし | 835µs | 365µs |
| **8** | 945µs | **287µs** |
| 100 | 1.1ms | **244µs** |
| 1,000 | 2.3ms | **237µs** |
| **8,000** | **11.2ms** | **516µs** |

### EXPLAIN 分析

#### 8 パーティション
```sql
EXPLAIN SELECT * FROM books_hash_8 WHERE id = 500000;
```
```
type: const
partitions: p0
key: PRIMARY
rows: 1
```
**考察**: 単一パーティションのみアクセス。パーティション特定のオーバーヘッドは最小限。

#### 8000 パーティション
```sql
EXPLAIN SELECT * FROM books_hash_8000 WHERE id = 500000;
```
```
type: const
partitions: p4000
key: PRIMARY
rows: 1
```
**考察**: EXPLAIN 上は単一パーティションだが、**8000パーティションのメタデータ管理オーバーヘッド**が発生。初回アクセスで11.2msもかかる原因。

### 分析
- 8〜1000: キャッシュ後は高速
- **8000: 初回が非常に遅い（11.2ms）**
- キャッシュ後も他より2倍遅い

---

## 2. ID範囲検索（10,001行）

### クエリ
```sql
SELECT COUNT(*) FROM books_hash_{N} WHERE id BETWEEN 100000 AND 110000;
```

### 結果

| パーティション数 | 時間 | 比較 |
|-----------------|------|------|
| 100 | **9.9ms** | baseline |
| 1,000 | 25.3ms | 2.5倍遅い |
| **8,000** | **1.1秒** | **111倍遅い** |

### EXPLAIN 分析

#### 100 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_100 WHERE id BETWEEN 100000 AND 110000;
```
```
type: range
partitions: p0,p1,p2,...,p99
key: PRIMARY
rows: 10001
```
**考察**: 100パーティション全てをスキャン。各パーティションで少量のデータを検索。

#### 8000 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8000 WHERE id BETWEEN 100000 AND 110000;
```
```
type: range
partitions: p0,p1,p2,...,p7999
key: PRIMARY
rows: 10001
```
**考察**: **8000パーティション全てをスキャン**。パーティションごとのオープン/クローズのオーバーヘッドが累積し、111倍の遅延。

### 分析
- **8000パーティションは壊滅的に遅い**
- HASH パーティションでの範囲検索は全パーティションスキャン
- パーティション数が多いとスキャンコストが増大

---

## 3. 日付範囲検索（16,041行）

### クエリ
```sql
SELECT COUNT(*) FROM books_hash_{N}
WHERE created_at BETWEEN '2022-06-01' AND '2022-06-30';
```

### 結果

| パーティション数 | 時間 | 比較 |
|-----------------|------|------|
| なし | 8.3ms | baseline |
| **8** | **3.1ms** | **最速** |
| 100 | 15.5ms | 5倍遅い |
| 1,000 | 21.6ms | 7倍遅い |
| **8,000** | **944ms** | **304倍遅い** |

### EXPLAIN 分析

#### 8 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8
WHERE created_at BETWEEN '2022-06-01' AND '2022-06-30';
```
```
type: range
partitions: p0,p1,p2,p3,p4,p5,p6,p7
key: idx_created_at
rows: 16041
Extra: Using where; Using index
```
**考察**: 8パーティション全スキャンだが、オーバーヘッドが小さい。インデックスで効率的に絞り込み。

#### 8000 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8000
WHERE created_at BETWEEN '2022-06-01' AND '2022-06-30';
```
```
type: range
partitions: p0,p1,p2,...,p7999
key: idx_created_at
rows: 16041
```
**考察**: **8000パーティション全てを開いてインデックススキャン**。各パーティションに平均2行しかないが、オープン/クローズコストが304倍の遅延を引き起こす。

### 分析
- **8パーティションが最速**
- パーティション数が増えると急激に遅くなる
- 8000は実用不可

---

## 4. Full Table COUNT

| パーティション数 | 時間 | 比較 |
|-----------------|------|------|
| なし | 299ms | baseline |
| **8** | **85ms** | **最速** |
| 100 | 193ms | - |
| **1,000** | **67ms** | 最速級 |
| 8,000 | 193ms | - |

### 分析
- 8 と 1000 が高速
- パーティションごとの COUNT が並列実行される可能性

---

## 5. テーブルサイズ

| パーティション数 | データサイズ | インデックスサイズ |
|-----------------|-------------|------------------|
| 8 | 0.13MB | 0.25MB |
| 100 | 1.56MB | 3.13MB |
| 1,000 | 15.63MB | 31.25MB |
| **8,000** | **125MB** | **250MB** |

### 分析
- パーティション数に比例してオーバーヘッド増大
- 8000パーティションでは375MBの追加オーバーヘッド

---

## 6. INSERT パフォーマンス

10,000,000件のINSERT時間（参考値）:

| パーティション数 | INSERT時間 |
|-----------------|-----------|
| 8 | 数分 |
| 100 | 数分 |
| 1,000 | 十数分 |
| **8,000** | **70分以上** |

### 分析
- 8000パーティションへのINSERTは極めて遅い
- バルクINSERTでも改善しない

---

## 推奨パーティション数

| ユースケース | 推奨数 | 理由 |
|-------------|-------|------|
| 一般的な用途 | **8〜16** | バランス最良 |
| 大量データ（100M+） | **50〜100** | 適度な分散 |
| 時系列データ | **年数 × 12** | 月ごと分割 |
| 絶対避けるべき | **1000以上** | オーバーヘッド大 |

---

## 結論

### 8000パーティションは実用不可
- 範囲検索: **100〜300倍遅い**
- INSERT: **70分以上**（10M件）
- ストレージオーバーヘッド: **375MB**

### 最適なパーティション数は 8〜100
- PK検索: 変わらないか高速
- 範囲検索: 適度に高速
- INSERT: 許容範囲
- ストレージ: 最小限のオーバーヘッド

### パーティション数の目安
```
最適パーティション数 ≈ 総レコード数 / 100,000〜1,000,000
```

- 1M件 → 8〜16 パーティション
- 10M件 → 16〜100 パーティション
- 100M件 → 100〜500 パーティション
