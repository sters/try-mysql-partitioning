# パーティション数の影響 比較レポート

## 概要

MySQL のパーティション上限は **8,192** 個。
パーティション数がパフォーマンスに与える影響を検証。

---

## テスト条件

- レコード数: **1,000,000件**
- パーティション種類: HASH(id)
- テストパターン: 8 / 100 / 1,000 / 8,000 パーティション

### 1パーティションあたりのレコード数

| パーティション数 | レコード数/パーティション |
|-----------------|-------------------------|
| 8 | 125,000 |
| 100 | 10,000 |
| 1,000 | 1,000 |
| 8,000 | 125 |

---

## 1. PK検索（単一行）

### クエリ
```sql
SELECT * FROM books_hash_{N} WHERE id = 500000;
```

### 結果

| パーティション数 | 初回 | キャッシュ後 |
|-----------------|------|-------------|
| なし | 835µs | 365µs |
| **8** | 945µs | **287µs** |
| 100 | 1.1ms | **244µs** |
| 1,000 | 2.3ms | **237µs** |
| **8,000** | **11.2ms** | **516µs** |

### EXPLAIN 分析

#### 8 パーティション
```sql
EXPLAIN SELECT * FROM books_hash_8 WHERE id = 500000;
```
```
type: const
partitions: p0
key: PRIMARY
rows: 1
```
**考察**: 単一パーティションのみアクセス。パーティション特定のオーバーヘッドは最小限。

#### 8000 パーティション
```sql
EXPLAIN SELECT * FROM books_hash_8000 WHERE id = 500000;
```
```
type: const
partitions: p4000
key: PRIMARY
rows: 1
```
**考察**: EXPLAIN 上は単一パーティションだが、**8000パーティションのメタデータ管理オーバーヘッド**が発生。初回アクセスで11.2msもかかる原因。

### 分析
- 8〜1000: キャッシュ後は高速
- **8000: 初回が非常に遅い（11.2ms）**
- キャッシュ後も他より2倍遅い

---

## 2. ID範囲検索（10,001行）

### クエリ
```sql
SELECT COUNT(*) FROM books_hash_{N} WHERE id BETWEEN 100000 AND 110000;
```

### 結果

| パーティション数 | 時間 | 比較 |
|-----------------|------|------|
| 100 | **9.9ms** | baseline |
| 1,000 | 25.3ms | 2.5倍遅い |
| **8,000** | **1.1秒** | **111倍遅い** |

### EXPLAIN 分析

#### 100 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_100 WHERE id BETWEEN 100000 AND 110000;
```
```
type: range
partitions: p0,p1,p2,...,p99
key: PRIMARY
rows: 10001
```
**考察**: 100パーティション全てをスキャン。各パーティションで少量のデータを検索。

#### 8000 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8000 WHERE id BETWEEN 100000 AND 110000;
```
```
type: range
partitions: p0,p1,p2,...,p7999
key: PRIMARY
rows: 10001
```
**考察**: **8000パーティション全てをスキャン**。パーティションごとのオープン/クローズのオーバーヘッドが累積し、111倍の遅延。

### 分析
- **8000パーティションは壊滅的に遅い**
- HASH パーティションでの範囲検索は全パーティションスキャン
- パーティション数が多いとスキャンコストが増大

---

## 3. 日付範囲検索（16,041行）

### クエリ
```sql
SELECT COUNT(*) FROM books_hash_{N}
WHERE created_at BETWEEN '2022-06-01' AND '2022-06-30';
```

### 結果

| パーティション数 | 時間 | 比較 |
|-----------------|------|------|
| なし | 8.3ms | baseline |
| **8** | **3.1ms** | **最速** |
| 100 | 15.5ms | 5倍遅い |
| 1,000 | 21.6ms | 7倍遅い |
| **8,000** | **944ms** | **304倍遅い** |

### EXPLAIN 分析

#### 8 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8
WHERE created_at BETWEEN '2022-06-01' AND '2022-06-30';
```
```
type: range
partitions: p0,p1,p2,p3,p4,p5,p6,p7
key: idx_created_at
rows: 16041
Extra: Using where; Using index
```
**考察**: 8パーティション全スキャンだが、オーバーヘッドが小さい。インデックスで効率的に絞り込み。

#### 8000 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8000
WHERE created_at BETWEEN '2022-06-01' AND '2022-06-30';
```
```
type: range
partitions: p0,p1,p2,...,p7999
key: idx_created_at
rows: 16041
```
**考察**: **8000パーティション全てを開いてインデックススキャン**。各パーティションに平均2行しかないが、オープン/クローズコストが304倍の遅延を引き起こす。

### 分析
- **8パーティションが最速**
- パーティション数が増えると急激に遅くなる
- 8000は実用不可

---

## 4. Full Table COUNT

### クエリ
```sql
SELECT COUNT(*) FROM books_hash_{N};
```

### 結果

| パーティション数 | 時間 | 比較 |
|-----------------|------|------|
| なし | 299ms | baseline |
| **8** | **85ms** | **最速** |
| 100 | 193ms | - |
| **1,000** | **67ms** | 最速級 |
| 8,000 | 193ms | - |

### EXPLAIN 分析

#### パーティションなし
```sql
EXPLAIN SELECT COUNT(*) FROM books;
```
```
type: index
key: PRIMARY
rows: 1000000
Extra: Using index
```
**考察**: 単一インデックスをシーケンシャルスキャン。

#### 8 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8;
```
```
type: index
partitions: p0,p1,p2,p3,p4,p5,p6,p7
key: PRIMARY
rows: 1000000
Extra: Using index
```
**考察**: 8パーティションを順次カウント。パーティション数が少ないためオーバーヘッド最小。

#### 8000 パーティション
```sql
EXPLAIN SELECT COUNT(*) FROM books_hash_8000;
```
```
type: index
partitions: p0,p1,p2,...,p7999
key: PRIMARY
rows: 1000000
Extra: Using index
```
**考察**: 8000パーティションを順次オープン/クローズ。各パーティションに125行しかないが、メタデータアクセスのオーバーヘッドが大きい。

### 分析
- 8 と 1000 が高速
- **意外な結果**: 1000パーティションが最速（67ms）の理由は不明。測定誤差の可能性もある
- **8000パーティション**: メタデータ管理のオーバーヘッドが大きく、8パーティションより遅い

---

## 5. テーブルサイズ

| パーティション数 | データサイズ | インデックスサイズ |
|-----------------|-------------|------------------|
| 8 | 0.13MB | 0.25MB |
| 100 | 1.56MB | 3.13MB |
| 1,000 | 15.63MB | 31.25MB |
| **8,000** | **125MB** | **250MB** |

### 分析
- パーティション数に比例してオーバーヘッド増大
- 8000パーティションでは375MBの追加オーバーヘッド

### なぜパーティション数でサイズが増えるのか？

| 要因 | 説明 |
|------|------|
| **メタデータ** | 各パーティションに .ibd ファイルとメタデータが必要 |
| **B-tree構造** | 各パーティションに独立したインデックスツリーが作成される |
| **ページの無駄** | 少量データでも最小ページサイズ（16KB）が割り当てられる |
| **内部フラグメント** | 小さなパーティションほどページ利用効率が低下 |

```
8パーティション: 1パーティション = 125,000行 → 効率的なページ利用
8000パーティション: 1パーティション = 125行 → 多くのページが空き状態
```

**計算例**:
- 8000パーティション × 最小16KBページ × 複数ページ ≈ 大量のオーバーヘッド

---

## 6. INSERT パフォーマンス

10,000,000件のINSERT時間（参考値）:

| パーティション数 | INSERT時間 |
|-----------------|-----------|
| 8 | 数分 |
| 100 | 数分 |
| 1,000 | 十数分 |
| **8,000** | **70分以上** |

### 分析
- 8000パーティションへのINSERTは極めて遅い
- バルクINSERTでも改善しない

### なぜ INSERT が遅いのか？

| フェーズ | 8パーティション | 8000パーティション |
|---------|---------------|-------------------|
| パーティション特定 | 高速（8分の1） | 低速（8000分の1の計算） |
| ファイルオープン | 8ファイル | 8000ファイル（OS制限に近い） |
| バッファプール | 効率的 | 頻繁なページイン/アウト |
| ロック競合 | 少ない | 多い（パーティションごとにロック） |

**バルクINSERTでも改善しない理由**:
```
1回のINSERTで複数行を挿入しても:
- 各行が異なるパーティションに分散
- パーティションごとにファイルアクセス
- 結果: シーケンシャルI/OがランダムI/Oになる
```

---

## 推奨パーティション数

| ユースケース | 推奨数 | 理由 |
|-------------|-------|------|
| 一般的な用途 | **8〜16** | 本検証で最速 |
| 大量データ（100M+） | **要検証** | 本検証では未検証のため推奨値を示せない |
| 時系列データ | **年数分** | 年ごと分割（月ごとは過剰な可能性） |
| 絶対避けるべき | **1000以上** | オーバーヘッド大 |

---

## 結論

### 8000パーティションは実用不可
- 範囲検索: **100〜300倍遅い**
- INSERT: **70分以上**（10M件）
- ストレージオーバーヘッド: **375MB**

### 最適なパーティション数は 8〜16
- PK検索: 変わらないか高速
- 範囲検索: 最も高速
- INSERT: 許容範囲
- ストレージ: 最小限のオーバーヘッド

### パーティション数の目安

**本検証データに基づく推奨**:

| データ量 | 推奨パーティション数 | 根拠 |
|---------|-------------------|------|
| 1M件 | **8〜16** | 検証で8が最速 |
| 10M件 | **8〜16** | 大きく増やすメリットなし |
| 100M件以上 | **要追加検証** | 本検証では未検証 |

**注意**: 100パーティションでは既に日付範囲検索が5倍遅くなる結果が出ている。「パーティション数を増やすほど良い」という考えは誤り。
