# 結論と推奨事項

## 主要な発見

### 1. インデックスが最も重要

| 比較 | 高速化率 |
|------|---------|
| インデックスなし → あり | **99%以上** |
| パーティションのみ追加 | 80〜95% |
| インデックス + パーティション | 99%以上 |

**結論**: まずインデックスを適切に設計すべき。パーティションは追加の最適化手段。

---

### 2. パーティションの効果が高いケース

| ユースケース | 効果 | 推奨パーティション |
|-------------|------|------------------|
| 日付範囲検索 | **65%高速** | RANGE(year/month) |
| 外部キー範囲検索 | **77%高速** | RANGE(fk_id) |
| PK単一検索 | 6%高速 | HASH(id) |
| 古いデータ削除 | **瞬時** | RANGE |

---

### 3. パーティションが逆効果のケース

| ケース | 影響 |
|--------|------|
| COUNT(*) | 2〜10倍遅い |
| パーティション跨ぎJOIN | 40%遅い |
| パーティション跨ぎ範囲検索 | 最大77%遅い |
| 8000パーティション | **100〜300倍遅い** |

---

### 4. 最適なパーティション数

| パーティション数 | 評価 |
|-----------------|------|
| 8〜16 | **最適** |
| 50〜100 | 良好 |
| 100〜500 | 許容範囲 |
| 1000以上 | **非推奨** |
| 8000 | **絶対避ける** |

---

## 推奨パーティション戦略

### 時系列データ（ログ、履歴）

```sql
PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);
```

**効果**: 日付範囲検索 **65%高速**、古いデータ削除が瞬時

---

### 大量データの均等分散

```sql
PARTITION BY HASH(id) PARTITIONS 8;
```

**効果**: PK検索 **6%高速**、データの均等分散

---

### 外部キーでの検索が多い場合

```sql
PARTITION BY RANGE (tenant_id) (
    PARTITION p0 VALUES LESS THAN (1000),
    PARTITION p1 VALUES LESS THAN (2000),
    ...
);
```

**効果**: 範囲検索 **77%高速**

---

## チェックリスト

### パーティション導入前

- [ ] インデックスは適切に設計されているか？
- [ ] パーティションキーでの検索が多いか？
- [ ] パーティションをまたぐクエリは少ないか？
- [ ] COUNT(*) の頻度は低いか？

### パーティション設計

- [ ] パーティション数は100以下か？
- [ ] パーティションキーは PRIMARY KEY に含まれるか？
- [ ] 外部キー制約は不要か（アプリで管理可能か）？
- [ ] 将来のパーティション追加計画はあるか？

---

## アンチパターン

### 1. パーティション数が多すぎる
```sql
-- NG: 8000パーティション
PARTITION BY HASH(id) PARTITIONS 8000;
```

### 2. パーティションキーでない列での検索
```sql
-- パーティションキー: created_at
-- NG: author_id での検索（全パーティションスキャン）
SELECT * FROM books WHERE author_id = 100;
```

### 3. パーティションをまたぐJOIN
```sql
-- パーティションが異なるテーブル間のJOINは遅い
SELECT * FROM books b
JOIN authors a ON b.author_id = a.id;
```

---

## 最終結論

### パーティションを使うべき場面
1. **日付範囲での検索が頻繁**（ログ、履歴）
2. **古いデータの一括削除が必要**（DROP PARTITION）
3. **特定の外部キー範囲での検索が多い**

### パーティションを使わないべき場面
1. **インデックスで十分な場合**
2. **COUNT(*) が頻繁**
3. **パーティションをまたぐクエリが多い**
4. **テーブルサイズが小さい**（100万件未満）

### ゴールデンルール
```
インデックス > パーティション
パーティション数は 8〜100 が最適
パーティションキーでの検索のみ高速化される
```

---

## EXPLAIN で見るべきポイント

### パーティションプルーニングの確認
```sql
EXPLAIN SELECT * FROM books_part WHERE created_at = '2022-06-15';
```
```
partitions: p2022  -- ← 単一パーティションのみ = 良好
```

### 全パーティションスキャンの検出
```sql
EXPLAIN SELECT * FROM books_hash WHERE created_at = '2022-06-15';
```
```
partitions: p0,p1,p2,p3,p4,p5,p6,p7  -- ← 全パーティション = 要注意
```

### インデックス使用の確認
```
type: const/ref/range  -- ← インデックス使用
type: ALL/index        -- ← フルスキャン（要改善）
Extra: Using index     -- ← カバリングインデックス（最良）
```

### 重要な指標
| EXPLAIN 項目 | 良好な値 | 要注意な値 |
|-------------|---------|-----------|
| partitions | 単一または少数 | 全パーティション |
| type | const, ref, range | ALL, index |
| rows | 予想行数が妥当 | 全件に近い |
| Extra | Using index | Using filesort |
