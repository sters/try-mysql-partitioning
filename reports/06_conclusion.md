# 結論と推奨事項

## 主要な発見

### 1. インデックスが最も重要

| 比較 | 時間削減率 |
|------|---------|
| インデックスなし → あり | **99%以上削減** |
| パーティションのみ追加 | 80〜95%削減 |
| インデックス + パーティション | 99%以上削減 |

**結論**: まずインデックスを適切に設計すべき。パーティションは追加の最適化手段。

---

### 2. パーティションの効果が高いケース

| ユースケース | 効果 | 推奨パーティション |
|-------------|------|------------------|
| 日付範囲検索 | **66%削減** | RANGE(year/month) |
| 外部キー範囲検索 | **77%削減** | RANGE(fk_id) |
| PK単一検索 | 6%削減 | HASH(id) |
| 古いデータ削除 | **瞬時** | RANGE |

---

### 3. パーティションが逆効果のケース

| ケース | 影響 |
|--------|------|
| COUNT(*) | 2〜10倍遅い |
| パーティション跨ぎJOIN | 40%遅い |
| パーティション跨ぎ範囲検索 | 最大77%遅い |
| 8000パーティション | **100〜300倍遅い** |

---

### 4. 最適なパーティション数

| パーティション数 | 評価 |
|-----------------|------|
| 8〜16 | **最適（検証で最速）** |
| 50〜100 | 許容範囲（ただし5倍遅くなる場合あり） |
| 100〜500 | 非推奨 |
| 1000以上 | **絶対避ける** |

---

## 推奨パーティション戦略

### 時系列データ（ログ、履歴）

```sql
PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);
```

**効果**: 日付範囲検索 **65%高速**、古いデータ削除が瞬時

---

### 大量データの均等分散

```sql
PARTITION BY HASH(id) PARTITIONS 8;
```

**効果**: PK検索 **6%高速**、データの均等分散

---

### 外部キーでの検索が多い場合

```sql
PARTITION BY RANGE (tenant_id) (
    PARTITION p0 VALUES LESS THAN (1000),
    PARTITION p1 VALUES LESS THAN (2000),
    ...
);
```

**効果**: 範囲検索 **77%高速**

---

## チェックリスト

### パーティション導入前

- [ ] インデックスは適切に設計されているか？
- [ ] パーティションキーでの検索が多いか？
- [ ] パーティションをまたぐクエリは少ないか？
- [ ] COUNT(*) の頻度は低いか？

### パーティション設計

- [ ] パーティション数は100以下か？
- [ ] パーティションキーは PRIMARY KEY に含まれるか？
- [ ] 外部キー制約は不要か（アプリで管理可能か）？
- [ ] 将来のパーティション追加計画はあるか？

---

## アンチパターン

### 1. パーティション数が多すぎる
```sql
-- NG: 8000パーティション
PARTITION BY HASH(id) PARTITIONS 8000;
```

### 2. パーティションキーでない列での検索
```sql
-- パーティションキー: created_at
-- NG: author_id での検索（全パーティションスキャン）
SELECT * FROM books WHERE author_id = 100;
```

### 3. パーティションをまたぐJOIN
```sql
-- パーティションが異なるテーブル間のJOINは遅い
SELECT * FROM books b
JOIN authors a ON b.author_id = a.id;
```

---

## 未検証事項と今後の課題

本検証では以下の項目について十分な検証ができていない。実運用での導入前には追加検証を推奨する。

### 1. パーティション運用操作

| 操作 | 未検証の理由 | 想定される影響 |
|------|------------|--------------|
| **REORGANIZE PARTITION** | 時間がかかるため未実施 | 大量データでは数時間〜数日の可能性 |
| **ADD PARTITION** | 単純な追加のみ確認 | MAXVALUE からの分割は重い可能性 |
| **COALESCE PARTITION** | HASH の縮小は未検証 | データ再配置のコストが不明 |
| **EXCHANGE PARTITION** | 未検証 | 一括データ入れ替えの効率が不明 |

```sql
-- 未検証: これらの操作時間
ALTER TABLE books REORGANIZE PARTITION p2022 INTO (
    PARTITION p2022_h1 VALUES LESS THAN ('2022-07-01'),
    PARTITION p2022_h2 VALUES LESS THAN ('2023-01-01')
);
```

### 2. 超大規模データ

| レコード数 | 検証状況 | 懸念事項 |
|-----------|---------|---------|
| 1,000,000 | ✓ 検証済み | - |
| 10,000,000 | ✓ 検証済み | - |
| 100,000,000 | **未検証** | メモリ、I/O ボトルネック |
| 1,000,000,000+ | **未検証** | パーティション戦略の再検討が必要な可能性 |

**懸念点**:
- 億単位ではパーティション数を増やす必要があるかもしれないが、本検証では 1000+ で急激に遅くなった
- 1パーティションあたりのデータ量の上限は不明
- バッファプールサイズとの関係が未検証

### 3. 同時実行・ロック

| 項目 | 検証状況 | 想定される影響 |
|------|---------|--------------|
| 並列 SELECT | **未検証** | パーティション間の並列度が不明 |
| 並列 INSERT | **未検証** | 同一パーティションへの競合 |
| SELECT + INSERT 混在 | **未検証** | ロック競合の可能性 |
| DDL 中のクエリ | **未検証** | ALGORITHM=INPLACE の効果 |

### 4. UPDATE / DELETE パフォーマンス

| 操作 | 検証状況 | 懸念事項 |
|------|---------|---------|
| 単一行 UPDATE | **未検証** | パーティションキー変更時の挙動 |
| 範囲 UPDATE | **未検証** | パーティションをまたぐ場合 |
| 大量 DELETE | **未検証** | DROP PARTITION 以外の削除 |
| パーティションキー変更 | **未検証** | 行の移動コスト |

```sql
-- 未検証: パーティションキーを変更すると行が移動する
UPDATE books SET created_at = '2021-01-01' WHERE id = 1;
-- → p2022 から p2021 へ行が移動（コストは？）
```

### 5. インフラ・環境依存

| 項目 | 本検証の環境 | 未検証の環境 |
|------|------------|------------|
| ストレージ | Docker (ローカルSSD) | HDD、NFS、EBS |
| メモリ | 十分なバッファプール | メモリ制限環境 |
| MySQL バージョン | 8.0 | 5.7、8.1+ |
| レプリケーション | なし | レプリカ遅延への影響 |
| バックアップ | 未検証 | mysqldump / xtrabackup の時間 |

### 6. オプティマイザ・統計情報

| 項目 | 検証状況 | 懸念事項 |
|------|---------|---------|
| ANALYZE TABLE | **未検証** | パーティションテーブルでの実行時間 |
| 統計情報の精度 | **未検証** | パーティションごとの統計の偏り |
| ヒストグラム | **未検証** | パーティションとの相互作用 |
| オプティマイザヒント | **未検証** | パーティション指定の効果 |

### 7. その他の未検証項目

- **サブクエリ**: パーティションテーブルを含むサブクエリの効率
- **ビュー**: パーティションテーブルに対するビューの性能
- **トリガー**: パーティションテーブルへのトリガー実行コスト
- **ストアドプロシージャ**: パーティション操作を含むプロシージャ
- **一時テーブル**: パーティションテーブルとの JOIN 効率
- **FOREIGN KEY エミュレーション**: アプリケーション側での整合性チェックコスト

---

## 検証の限界

本検証には以下の限界がある:

1. **単一クライアント**: 同時接続数1での測定。実運用では並列アクセスが発生
2. **ローカル環境**: ネットワーク遅延なし。クラウド環境では異なる可能性
3. **均一なデータ**: テストデータは均一に分布。実データでは偏りがある
4. **短期間の測定**: キャッシュウォームアップ後の測定。長期運用での劣化は不明
5. **単純なクエリ**: 複雑な JOIN やサブクエリは限定的な検証

---

## 最終結論

### パーティションを使うべき場面
1. **日付範囲での検索が頻繁**（ログ、履歴）
2. **古いデータの一括削除が必要**（DROP PARTITION）
3. **特定の外部キー範囲での検索が多い**
4. **データ量が1000万件以上**で、パーティションキーでの検索がメイン

### パーティションを使わないべき場面
1. **インデックスで十分な場合**（まずインデックスを検討）
2. **COUNT(*) が頻繁**
3. **パーティションをまたぐクエリが多い**
4. **テーブルサイズが小さい**（100万件未満）
5. **パーティション運用のコストを許容できない場合**

### ゴールデンルール
```
インデックス > パーティション
パーティション数は 8〜100 が最適
パーティションキーでの検索のみ高速化される
```

### 導入前の追加検証を推奨

本検証の結果は**参考値**として扱うべき。実運用導入前には:

1. **実際のデータ分布**でのベンチマーク
2. **実際のクエリパターン**での EXPLAIN 確認
3. **REORGANIZE / ADD PARTITION** の所要時間測定
4. **並列アクセス**での性能測定
5. **本番相当のハードウェア**でのテスト

### 段階的な導入アプローチ

```
1. まずインデックスを最適化
   ↓
2. それでも遅い場合、小規模テーブルでパーティション検証
   ↓
3. 効果が確認できたら、本番データの一部でテスト
   ↓
4. 運用手順（ADD/DROP PARTITION）を確立
   ↓
5. 本番導入
```

---

## EXPLAIN で見るべきポイント

### パーティションプルーニングの確認
```sql
EXPLAIN SELECT * FROM books_part WHERE created_at = '2022-06-15';
```
```
partitions: p2022  -- ← 単一パーティションのみ = 良好
```

### 全パーティションスキャンの検出
```sql
EXPLAIN SELECT * FROM books_hash WHERE created_at = '2022-06-15';
```
```
partitions: p0,p1,p2,p3,p4,p5,p6,p7  -- ← 全パーティション = 要注意
```

### インデックス使用の確認
```
type: const/ref/range  -- ← インデックス使用
type: ALL/index        -- ← フルスキャン（要改善）
Extra: Using index     -- ← カバリングインデックス（最良）
```

### 重要な指標
| EXPLAIN 項目 | 良好な値 | 要注意な値 |
|-------------|---------|-----------|
| partitions | 単一または少数 | 全パーティション |
| type | const, ref, range | ALL, index |
| rows | 予想行数が妥当 | 全件に近い |
| Extra | Using index | Using filesort |
