# MySQL パーティション実験 概要レポート

## 実験の目的

MySQL のパーティション機能について、以下を検証する:

1. **インデックスとパーティションの比較**: どちらがより効果的か？
2. **パーティション種類の比較**: HASH, RANGE, LIST, KEY の使い分け
3. **パーティション数の影響**: 最適なパーティション数は？
4. **実運用での注意点**: パーティションが逆効果になるケース

## 実験環境

- MySQL 8.0
- Docker コンテナ (ローカル環境)
- Go 1.25

## テストデータ

| テーブル | レコード数 | 用途 |
|---------|-----------|------|
| books | 1,000,000〜10,000,000 | メインテスト対象 |
| authors | 100,000〜10,000,000 | 外部キー参照元 |
| book_tags | 1,000,000〜50,000,000 | 中間テーブル |
| tags | 1,000 | マスタデータ |

## テストパターン

### 1. インデックス vs パーティション
- インデックスなし・パーティションなし
- インデックスあり・パーティションなし
- インデックスなし・パーティションあり
- インデックスあり・パーティションあり

### 2. パーティション種類
- HASH (id)
- RANGE (created_at / year)
- RANGE (id)
- RANGE (author_id / 外部キー)
- LIST (status)
- KEY (複合キー)

### 3. パーティション数
- 8 パーティション
- 100 パーティション
- 1,000 パーティション
- 8,000 パーティション

## レポート一覧

1. [インデックス vs パーティション比較](02_index_vs_partition.md)
2. [パーティション種類別比較](03_partition_types.md)
3. [外部キーパーティション](04_foreign_key_partition.md)
4. [パーティション数の影響](05_partition_count.md)
5. [結論と推奨事項](06_conclusion.md)

---

## 主要な発見（サマリー）

### インデックス vs パーティション

| 構成 | 日付範囲検索 | PK検索 | COUNT(*) |
|------|------------|--------|----------|
| なし | baseline | baseline | **最速** |
| インデックスのみ | **99.8%高速** | **99.9%高速** | 10倍遅い |
| パーティションのみ | 93.7%高速 | 6%高速 | 10倍遅い |
| **両方** | **99.8%高速** | **99.99%高速** | **16倍遅い** |

**結論**: インデックスが最重要。パーティションは追加の最適化手段。

### パーティション数の影響

| パーティション数 | 範囲検索 | INSERT(10M件) |
|-----------------|---------|---------------|
| 8 | **最速** | 数分 |
| 100 | 5倍遅い | 数分 |
| 1,000 | 7倍遅い | 十数分 |
| 8,000 | **304倍遅い** | **70分以上** |

**結論**: パーティション数は 8〜100 が最適。1000以上は避ける。

### パーティション種類の使い分け

| 種類 | 最適なユースケース | 避けるべきケース |
|------|------------------|----------------|
| HASH | PK検索、均等分散 | 範囲検索 |
| RANGE(日付) | 時系列データ、ログ削除 | GROUP BY |
| RANGE(ID) | アーカイブ | - |
| LIST | マルチテナント | 多値ステータス |
| KEY | 複合キー検索 | 部分キー検索 |
